
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/cycle.ipynb

import os
import time
import yaml
import json
import datetime
import logging
import numpy as np
from pathlib import Path
from collections import namedtuple
import matplotlib.pyplot as plt
#%matplotlib inline

def from_range(start, end, num, dist=None):
    if dist is None:
        dist = np.random.random
    lstart, lend = np.log(start), np.log(end)
    ar = np.logspace(lstart, lend, num, base=np.e)
    return ar

def get_dist(start, end, num, space, to_int=False):
    if space == 'log':
        space = np.geomspace
    elif space == 'lin':
        space = np.linspace
    else:
        raise NotImplementedError
    arr = space(start, end, num).astype(np.float32)
    if to_int:
        arr = arr.astype(np.int32)
    return arr

def dump_state(state, path, name, is_config=True, yaml_dump=True):
    timestamp = '{:%Y_%b_%d_%H_%M_%S}'.format(datetime.datetime.now())
    prefix = 'config_' if is_config else ''
    if yaml_dump:
        dump = yaml.safe_dump
        postfix = '.yaml'
    else:
        dump = json.dumps
        postfix = '.json'

    p = path/f'{prefix}{timestamp}_{name}{postfix}'
    with open(p, 'w') as f:
        f.write(dump(state, indent=4))
    return p


def init_params(raw_params):
    params = []
    print(raw_params)
    for kwargs in raw_params:
        print(kwargs)
        param = Param(**kwargs)
        sampling = kwargs['sampling']
        assert sampling == 'random' or sampling == 'sequential', sampling
        params.append({'sampling':sampling, 'instance':param})
    return params

class Param:
    def __init__(self, name, arr, **kwargs):
        self.name = name
        self.arr = arr
        self.count = 0

    def __len__(self):
        return len(self.arr)

    def __getitem__(self, i):
        i = i%self.__len__()
        return self.arr[i]

    def get_random(self):
        return self.__getitem__(np.random.choice(self.__len__()))

    def safe_get_next(self):
        val = self.__getitem__(self.count)
        self.count = self.count+1 if self.count < self.__len__()-1 else 0
        return val

    def get_next(self):
        if self.count >= self.__len__():
            raise StopIteration
        val = self.__getitem__(self.count)
        self.count += 1
        return val

    def reset_count(self):
        self.count=0

    def __repr__(self):
        return f'Param : {self.name} | {str(self.arr)}'

    def plot(self):
        plt.hist(self.arr, bins=10)


class BaseConfigCycler:
    def get_values(self, params_dist, idx):
        values = {}
        for param in params_dist:
            sampling = param['sampling']
            if sampling == 'random':
                val = param['instance'].get_random()
            else:#elif sampling == 'sequential':
                if idx is not None:
                    val = param['instance'].__getitem__(idx)
                else:
                    val = param['instance'].safe_get_next()

            values[param['instance'].name] = val
        return values

    def init_map(self):
        raise NotImplementedError

    def create_state(self, raw, idx=None):
        params_dist = init_params(raw)
        new_params = self.get_values(params_dist, idx)
        params_map = self.init_map()
        cfg = {}
        for name, (full_name, p_type, default_value) in params_map.items():
            value = new_params.get(name, default_value)
            if value is not np.NaN:
                cfg[full_name] = p_type(value)
        return new_params, cfg