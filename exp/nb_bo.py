
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/bo.ipynb

from bayes_opt import BayesianOptimization, UtilityFunction, SequentialDomainReductionTransformer
import numpy as np
from pprint import pprint

def mean_duplicates(points):
    uni_params = {}
    targets = {}
    for i, p in enumerate(points):
        param, target = p['params'], p['target']
        for k,v in uni_params.items():
            if param == v:
                targets[k].append(target)
                break
        else:
            uni_params[i] = param
            targets[i] = [target]

    res = []
    for k, v in uni_params.items():
        res.append({'params':v, 'target':np.mean(targets[k])})

    return res


class BaseConfigBo:
    def __init__(self):
        self.utility = UtilityFunction(kind="ei", kappa=1, xi=0.1)

    def get_values(self, optimizer):
        return optimizer.suggest(self.utility)

    def init_opt(self, bounds):
        return BayesianOptimization(f=None,
                                    pbounds=bounds,
                                   random_state=1)
                                    #bounds_transformer=SequentialDomainReductionTransformer())

    def register(self, opt, points):
        for point in points:
            opt.register(
                params=point['params'],
                target=point['target'],)

    def init_map(self):
        raise NotImplementedError

    def read_params(self, params):
        bounds = {}
        for p in params:
            bounds[p['name']] = p['bounds']
        return bounds

    def create_state(self, points, params):
        bounds = self.read_params(params)
        o = self.init_opt(bounds)
        if points:
            points = mean_duplicates(points)
            #pprint(points, indent=4)
            self.register(o, points)
        print(o.res)
        print([self.get_values(o) for i in range(10)])
        new_params = self.get_values(o)
        params_map = self.init_map()
        cfg = {}
        for name, (full_name, p_type, default_value) in params_map.items():
            value = new_params.get(name, default_value)
            if value is not np.NaN:
                cfg[full_name] = p_type(value)
        return new_params, cfg